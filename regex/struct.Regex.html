<!DOCTYPE html><html lang="en" data-bs-color-scheme="light"><head><title>Regex in regex - Rust</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="light dark"><link href="https://cdn.jsdelivr.net/npm/bootstrap-dark-5@1.1.3/dist/css/bootstrap-blackbox.min.css" integrity="sha384-nXtYGwAUBOgb4M8Eo9xOK3Er3bVPQo1HguUNWf/RheIagsbCaP3ZaYqVeUqHEr20" rel="stylesheet" crossorigin="anonymous"><link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" integrity="sha384-tKLJeE1ALTUwtXlaGjJYM3sejfssWdAaWR2s97axw4xkiAdMzQjtOjgcyw0Y50KU" rel="stylesheet" crossorigin="anonymous"><link href="../style.css" rel="stylesheet"><link href="../rust.svg" rel="icon" type="image/svg+xml"></head><body><header class="navbar navbar-expand-md navbar-dark rd-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-2" href="../regex/index.html" aria-label="Rust"><img src="../rust.svg" width="40" height="40" alt="Rust Logo"></a><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#rdNavbar" aria-controls="rdNavbar" aria-expanded="false" aria-label="Toggle navigation"><i class="bi bi-list"></i></button><div class="collapse navbar-collapse" id="rdNavbar"><ul class="navbar-nav flex-row flex-wrap pt-2 py-md-0"><li class="nav-item col-6 col-md-auto"><a class="nav-link p-2 active" href="../regex/index.html">regex</a></li></ul><hr class="d-md-none text-white-50"><ul class="navbar-nav flex-row flex-wrap ms-md-auto"><li class="nav-item col-6 col-md-auto"><a class="nav-link p-2" href="#themes" title="Toggle themes" onclick="darkmode.toggleDarkMode()"><i class="bi bi-palette"></i><small class="d-md-none ms-2">Themes</small></a></li><li class="nav-item col-6 col-md-auto" title="Unimplemented"><a class="nav-link p-2" href="#shortcuts"><i class="bi bi-question-lg"></i><small class="d-md-none ms-2">Shortcut</small></a></li><li class="nav-item col-6 col-md-auto" title="Unimplemented"><a class="nav-link p-2" href="#options"><i class="bi bi-wrench"></i><small class="d-md-none ms-2">Options</small></a></li></ul></div></nav></header><nav class="rd-subnavbar py-2 border-bottom shadow-sm" aria-label="Secondary navigation"><div class="container-xxl d-flex align-items-md-center"><form class="rd-search position-relative" id="rd-search-form"><span class="w-100" style="position: relative; display: inline-block; direction: ltr;"><input type="search" class="form-control ds-input" id="rd-search-input" placeholder="Search in regex..." aria-label="Search docs for..." autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-owns="rd-search-menu" style="position: relative; vertical-align: top;" dir="auto"><span class="ds-dropdown-menu" style="position: absolute; top: 100%; z-index: 100; display: none; left: 0px; right: 0px;" role="listbox" id="rd-search-menu"><div class="rd-search-items" id="rd-search-items"></div></span></span></form><button class="btn rd-sidebar-toggle d-md-none py-0 px-1 ms-3 order-3 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#rd-docs-nav" aria-controls="rd-docs-nav" aria-expanded="false" aria-label="Toggle docs navigation"><i class="bi bi-arrows-expand"></i><i class="bi bi-arrows-collapse"></i></button></div></nav><div id="main" class="container-xxl"><div class="rd-main"><div class="rd-intro"><h1 id="item-title" class="rd-anchor item-title">Struct <a class="mod" href="index.html">regex</a>::<wbr><a class="struct" href="struct.Regex.html">Regex</a></h1><pre id="item-definition" class="rd-anchor item-definition"><code><span class="kw">pub</span>&nbsp;<span class="kw">struct</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span><span class="ponct">(</span><span class="ponct">_</span><span class="ponct">)</span><span class="ponct">;</span></code></pre><details id="item-documentation" class="rd-anchor item-documentation" open=""><summary>Documentation</summary><div class="mt-2"><p>A compiled regular expression for matching Unicode strings.</p>
<p>It is represented as either a sequence of bytecode instructions (dynamic)
or as a specialized Rust function (native). It can be used to search, split
or replace text. All searching is done with an implicit <code>.*?</code> at the
beginning and end of an expression. To force an expression to match the
whole string (or a prefix or a suffix), you must use an anchor like <code>^</code> or
<code>$</code> (or <code>\A</code> and <code>\z</code>).</p>
<p>While this crate will handle Unicode strings (whether in the regular
expression or in the search text), all positions returned are <strong>byte
indices</strong>. Every byte index is guaranteed to be at a Unicode code point
boundary.</p>
<p>The lifetimes <code>'r</code> and <code>'t</code> in this crate correspond to the lifetime of a
compiled regular expression and text to search, respectively.</p>
<p>The only methods that allocate new strings are the string replacement
methods. All other methods (searching and splitting) return borrowed
pointers into the string given.</p>
<h2 class="rd-anchor" id="examples">Examples<a aria-label="anchor" href="#examples"><i class="bi bi-hash"></i></a></h2>
<p>Find the location of a US phone number:</p>
<pre><code class="language-rust">let re = Regex::new(&quot;[0-9]{3}-[0-9]{3}-[0-9]{4}&quot;).unwrap();
let mat = re.find(&quot;phone: 111-222-3333&quot;).unwrap();
assert_eq!((mat.start(), mat.end()), (7, 19));</code></pre><h2 class="rd-anchor" id="using-the-stdstrpattern-methods-with-regex">Using the <code>std::str::pattern</code> methods with <code>Regex</code><a aria-label="anchor" href="#using-the-stdstrpattern-methods-with-regex"><i class="bi bi-hash"></i></a></h2>
<blockquote>
<p><strong>Note</strong>: This section requires that this crate is compiled with the
<code>pattern</code> Cargo feature enabled, which <strong>requires nightly Rust</strong>.</p>
</blockquote>
<p>Since <code>Regex</code> implements <code>Pattern</code>, you can use regexes with methods
defined on <code>&amp;str</code>. For example, <code>is_match</code>, <code>find</code>, <code>find_iter</code>
and <code>split</code> can be replaced with <code>str::contains</code>, <code>str::find</code>,
<code>str::match_indices</code> and <code>str::split</code>.</p>
<p>Here are some examples:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;\d+&quot;).unwrap();
let haystack = &quot;a111b222c&quot;;

assert!(haystack.contains(&amp;re));
assert_eq!(haystack.find(&amp;re), Some(1));
assert_eq!(haystack.match_indices(&amp;re).collect::&lt;Vec&lt;_&gt;&gt;(),
           vec![(1, 4), (5, 8)]);
assert_eq!(haystack.split(&amp;re).collect::&lt;Vec&lt;_&gt;&gt;(), vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);</code></pre></div></details></div><div id="rd-docs-nav" class="rd-toc ps-xl-3 collapse"><strong class="d-block h6 my-2 pb-2 border-bottom">On this page</strong><nav id="TableOfContents"><ul><li><a href="#item-title" class="d-inline-flex align-items-center rounded"><strong>Regex</strong></a></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#item-documentation" data-bs-toggle="collapse" data-bs-target="#toc-documentation" aria-expanded="true" aria-current="true"><strong>Documentation</strong></a><ul id="toc-documentation" class="collapse show"><li><a href="#examples" class="d-inline-block align-items-center rounded">Examples</a></li><li><a href="#using-the-stdstrpattern-methods-with-regex" class="d-inline-block align-items-center rounded">Using the std::str::pattern methods with Regex</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#methods" data-bs-toggle="collapse" data-bs-target="#toc-methods" aria-expanded="true" aria-current="true"><strong>Methods</strong></a><ul id="toc-methods" class="collapse show"><li><a href="#method.new" class="d-inline-block align-items-center rounded">new</a></li><li><a href="#method.is_match" class="d-inline-block align-items-center rounded">is_match</a></li><li><a href="#method.find" class="d-inline-block align-items-center rounded">find</a></li><li><a href="#method.find_iter" class="d-inline-block align-items-center rounded">find_iter</a></li><li><a href="#method.captures" class="d-inline-block align-items-center rounded">captures</a></li><li><a href="#method.captures_iter" class="d-inline-block align-items-center rounded">captures_iter</a></li><li><a href="#method.split" class="d-inline-block align-items-center rounded">split</a></li><li><a href="#method.splitn" class="d-inline-block align-items-center rounded">splitn</a></li><li><a href="#method.replace" class="d-inline-block align-items-center rounded">replace</a></li><li><a href="#method.replace_all" class="d-inline-block align-items-center rounded">replace_all</a></li><li><a href="#method.replacen" class="d-inline-block align-items-center rounded">replacen</a></li><li><a href="#method.shortest_match" class="d-inline-block align-items-center rounded">shortest_match</a></li><li><a href="#method.shortest_match_at" class="d-inline-block align-items-center rounded">shortest_match_at</a></li><li><a href="#method.is_match_at" class="d-inline-block align-items-center rounded">is_match_at</a></li><li><a href="#method.find_at" class="d-inline-block align-items-center rounded">find_at</a></li><li><a href="#method.captures_read" class="d-inline-block align-items-center rounded">captures_read</a></li><li><a href="#method.captures_read_at" class="d-inline-block align-items-center rounded">captures_read_at</a></li><li><a href="#method.as_str" class="d-inline-block align-items-center rounded">as_str</a></li><li><a href="#method.capture_names" class="d-inline-block align-items-center rounded">capture_names</a></li><li><a href="#method.captures_len" class="d-inline-block align-items-center rounded">captures_len</a></li><li><a href="#method.capture_locations" class="d-inline-block align-items-center rounded">capture_locations</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#trait-implementations" data-bs-toggle="collapse" data-bs-target="#toc-trait-implementations" aria-expanded="true" aria-current="true"><strong>Trait Implementations</strong></a><ul id="toc-trait-implementations" class="collapse show"><li><a href="#impl-Clone-for-Regex" class="d-inline-block align-items-center rounded">Clone</a></li><li><a href="#impl-Debug-for-Regex" class="d-inline-block align-items-center rounded">Debug</a></li><li><a href="#impl-Display-for-Regex" class="d-inline-block align-items-center rounded">Display</a></li><li><a href="#impl-FromStr-for-Regex" class="d-inline-block align-items-center rounded">FromStr</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#auto-trait-implementations" data-bs-toggle="collapse" data-bs-target="#toc-auto-trait-implementations" aria-expanded="true" aria-current="true"><strong>Auto Trait Implementations</strong></a><ul id="toc-auto-trait-implementations" class="collapse show"><li><a href="#impl-RefUnwindSafe-for-Regex" class="d-inline-block align-items-center rounded">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Regex" class="d-inline-block align-items-center rounded">Send</a></li><li><a href="#impl-Sync-for-Regex" class="d-inline-block align-items-center rounded">Sync</a></li><li><a href="#impl-Unpin-for-Regex" class="d-inline-block align-items-center rounded">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Regex" class="d-inline-block align-items-center rounded">UnwindSafe</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#blanket-implementations" data-bs-toggle="collapse" data-bs-target="#toc-blanket-implementations" aria-expanded="true" aria-current="true"><strong>Blanket Implementations</strong></a><ul id="toc-blanket-implementations" class="collapse show"><li><a href="#impl-T-Any-for-TwhereT-'static-?Sized" class="d-inline-block align-items-center rounded">Any</a></li><li><a href="#impl-T-Borrow-T-for-TwhereT-?Sized" class="d-inline-block align-items-center rounded">Borrow&lt;T&gt;</a></li><li><a href="#impl-T-BorrowMut-T-for-TwhereT-?Sized" class="d-inline-block align-items-center rounded">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-T-From-T-for-T" class="d-inline-block align-items-center rounded">From&lt;T&gt;</a></li><li><a href="#impl-T-U-Into-U-for-TwhereU-From-T" class="d-inline-block align-items-center rounded">Into&lt;U&gt;</a></li><li><a href="#impl-T-ToOwned-for-TwhereT-Clone" class="d-inline-block align-items-center rounded">ToOwned</a></li><li><a href="#impl-T-ToString-for-TwhereT-Display-?Sized" class="d-inline-block align-items-center rounded">ToString</a></li><li><a href="#impl-T-U-TryFrom-U-for-TwhereU-Into-T" class="d-inline-block align-items-center rounded">TryFrom&lt;U&gt;</a></li><li><a href="#impl-T-U-TryInto-U-for-TwhereU-TryFrom-T" class="d-inline-block align-items-center rounded">TryInto&lt;U&gt;</a></li></ul></li></ul></nav></div><div class="rd-content"><section><h2 id="implementations" class="rd-anchor">Implementations<a aria-label="anchor" href="#implementations"><i class="bi bi-hash"></i></a></h2><div class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"><p>Core regular expression methods.</p>
</div><div style="padding-left:1.5rem;"><div id="method.new" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.new">new</a></span><span class="ponct">(</span><span>re</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Regex.html">Regex</a></span><span class="ponct">,</span>&nbsp;<span class="ident enum"><a href="enum.Error.html">Error</a></span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Compiles a regular expression. Once compiled, it can be used repeatedly
to search, split or replace text in a string.</p>
<p>If an invalid expression is given, then an error is returned.</p>
</div></details></div><div id="method.is_match" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.is_match">is_match</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="primitive">bool</span></code></summary><div class="mt-2 item-documentation"><p>Returns true if and only if there is a match for the regex in the
string given.</p>
<p>It is recommended to use this method if all you need to do is test
a match, since the underlying matching engine may be able to do less
work.</p>
<h2 class="rd-anchor" id="method.is_match.example">Example<a aria-label="anchor" href="#method.is_match.example"><i class="bi bi-hash"></i></a></h2>
<p>Test if some text contains at least one word with exactly 13
Unicode word characters:</p>
<pre><code class="language-rust">let text = &quot;I categorically deny having triskaidekaphobia.&quot;;
assert!(Regex::new(r&quot;\b\w{13}\b&quot;).unwrap().is_match(text));</code></pre></div></details></div><div id="method.find" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.find">find</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Match.html">Match</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns the start and end byte range of the leftmost-first match in
<code>text</code>. If no match exists, then <code>None</code> is returned.</p>
<p>Note that this should only be used if you want to discover the position
of the match. Testing the existence of a match is faster if you use
<code>is_match</code>.</p>
<h2 class="rd-anchor" id="method.find.example">Example<a aria-label="anchor" href="#method.find.example"><i class="bi bi-hash"></i></a></h2>
<p>Find the start and end location of the first word with exactly 13
Unicode word characters:</p>
<pre><code class="language-rust">let text = &quot;I categorically deny having triskaidekaphobia.&quot;;
let mat = Regex::new(r&quot;\b\w{13}\b&quot;).unwrap().find(text).unwrap();
assert_eq!(mat.start(), 2);
assert_eq!(mat.end(), 15);</code></pre></div></details></div><div id="method.find_iter" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.find_iter">find_iter</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><span class="kw">&</span><span>'r</span>&nbsp;<span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.Matches.html">Matches</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns an iterator for each successive non-overlapping match in
<code>text</code>, returning the start and end byte indices with respect to
<code>text</code>.</p>
<h2 class="rd-anchor" id="method.find_iter.example">Example<a aria-label="anchor" href="#method.find_iter.example"><i class="bi bi-hash"></i></a></h2>
<p>Find the start and end location of every word with exactly 13 Unicode
word characters:</p>
<pre><code class="language-rust">let text = &quot;Retroactively relinquishing remunerations is reprehensible.&quot;;
for mat in Regex::new(r&quot;\b\w{13}\b&quot;).unwrap().find_iter(text) {
    println!(&quot;{:?}&quot;, mat);
}</code></pre></div></details></div><div id="method.captures" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.captures">captures</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Captures.html">Captures</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns the capture groups corresponding to the leftmost-first
match in <code>text</code>. Capture group <code>0</code> always corresponds to the entire
match. If no match is found, then <code>None</code> is returned.</p>
<p>You should only use <code>captures</code> if you need access to the location of
capturing group matches. Otherwise, <code>find</code> is faster for discovering
the location of the overall match.</p>
<h2 class="rd-anchor" id="method.captures.examples">Examples<a aria-label="anchor" href="#method.captures.examples"><i class="bi bi-hash"></i></a></h2>
<p>Say you have some text with movie names and their release years,
like “‘Citizen Kane’ (1941)”. It’d be nice if we could search for text
looking like that, while also extracting the movie name and its release
year separately.</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;'([^']+)'\s+\((\d{4})\)&quot;).unwrap();
let text = &quot;Not my favorite movie: 'Citizen Kane' (1941).&quot;;
let caps = re.captures(text).unwrap();
assert_eq!(caps.get(1).unwrap().as_str(), &quot;Citizen Kane&quot;);
assert_eq!(caps.get(2).unwrap().as_str(), &quot;1941&quot;);
assert_eq!(caps.get(0).unwrap().as_str(), &quot;'Citizen Kane' (1941)&quot;);
// You can also access the groups by index using the Index notation.
// Note that this will panic on an invalid index.
assert_eq!(&amp;caps[1], &quot;Citizen Kane&quot;);
assert_eq!(&amp;caps[2], &quot;1941&quot;);
assert_eq!(&amp;caps[0], &quot;'Citizen Kane' (1941)&quot;);</code></pre>
<p>Note that the full match is at capture group <code>0</code>. Each subsequent
capture group is indexed by the order of its opening <code>(</code>.</p>
<p>We can make this example a bit clearer by using <em>named</em> capture groups:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;'(?P&lt;title&gt;[^']+)'\s+\((?P&lt;year&gt;\d{4})\)&quot;)
               .unwrap();
let text = &quot;Not my favorite movie: 'Citizen Kane' (1941).&quot;;
let caps = re.captures(text).unwrap();
assert_eq!(caps.name(&quot;title&quot;).unwrap().as_str(), &quot;Citizen Kane&quot;);
assert_eq!(caps.name(&quot;year&quot;).unwrap().as_str(), &quot;1941&quot;);
assert_eq!(caps.get(0).unwrap().as_str(), &quot;'Citizen Kane' (1941)&quot;);
// You can also access the groups by name using the Index notation.
// Note that this will panic on an invalid group name.
assert_eq!(&amp;caps[&quot;title&quot;], &quot;Citizen Kane&quot;);
assert_eq!(&amp;caps[&quot;year&quot;], &quot;1941&quot;);
assert_eq!(&amp;caps[0], &quot;'Citizen Kane' (1941)&quot;);
</code></pre>
<p>Here we name the capture groups, which we can access with the <code>name</code>
method or the <code>Index</code> notation with a <code>&amp;str</code>. Note that the named
capture groups are still accessible with <code>get</code> or the <code>Index</code> notation
with a <code>usize</code>.</p>
<p>The <code>0</code>th capture group is always unnamed, so it must always be
accessed with <code>get(0)</code> or <code>[0]</code>.</p>
</div></details></div><div id="method.captures_iter" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.captures_iter">captures_iter</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><span class="kw">&</span><span>'r</span>&nbsp;<span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.CaptureMatches.html">CaptureMatches</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns an iterator over all the non-overlapping capture groups matched
in <code>text</code>. This is operationally the same as <code>find_iter</code>, except it
yields information about capturing group matches.</p>
<h2 class="rd-anchor" id="method.captures_iter.example">Example<a aria-label="anchor" href="#method.captures_iter.example"><i class="bi bi-hash"></i></a></h2>
<p>We can use this to find all movie titles and their release years in
some text, where the movie is formatted like “‘Title’ (xxxx)”:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;'(?P&lt;title&gt;[^']+)'\s+\((?P&lt;year&gt;\d{4})\)&quot;)
               .unwrap();
let text = &quot;'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).&quot;;
for caps in re.captures_iter(text) {
    println!(&quot;Movie: {:?}, Released: {:?}&quot;,
             &amp;caps[&quot;title&quot;], &amp;caps[&quot;year&quot;]);
}
// Output:
// Movie: Citizen Kane, Released: 1941
// Movie: The Wizard of Oz, Released: 1939
// Movie: M, Released: 1931</code></pre></div></details></div><div id="method.split" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.split">split</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><span class="kw">&</span><span>'r</span>&nbsp;<span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.Split.html">Split</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns an iterator of substrings of <code>text</code> delimited by a match of the
regular expression. Namely, each element of the iterator corresponds to
text that <em>isn’t</em> matched by the regular expression.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h2 class="rd-anchor" id="method.split.example">Example<a aria-label="anchor" href="#method.split.example"><i class="bi bi-hash"></i></a></h2>
<p>To split a string delimited by arbitrary amounts of spaces or tabs:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;[ \t]+&quot;).unwrap();
let fields: Vec&lt;&amp;str&gt; = re.split(&quot;a b \t  c\td    e&quot;).collect();
assert_eq!(fields, vec![&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]);</code></pre></div></details></div><div id="method.splitn" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.splitn">splitn</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>'r</span>&nbsp;<span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>limit</span><span class="ponct">:</span>&nbsp;<span class="primitive">usize</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.SplitN.html">SplitN</a></span><span class="ponct">&lt;</span><span>'r</span><span class="ponct">,</span>&nbsp;<span>'t</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns an iterator of at most <code>limit</code> substrings of <code>text</code> delimited
by a match of the regular expression. (A <code>limit</code> of <code>0</code> will return no
substrings.) Namely, each element of the iterator corresponds to text
that <em>isn’t</em> matched by the regular expression. The remainder of the
string that is not split will be the last element in the iterator.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h2 class="rd-anchor" id="method.splitn.example">Example<a aria-label="anchor" href="#method.splitn.example"><i class="bi bi-hash"></i></a></h2>
<p>Get the first two words in some text:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;\W+&quot;).unwrap();
let fields: Vec&lt;&amp;str&gt; = re.splitn(&quot;Hey! How are you?&quot;, 3).collect();
assert_eq!(fields, vec!(&quot;Hey&quot;, &quot;How&quot;, &quot;are you?&quot;));</code></pre></div></details></div><div id="method.replace" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.replace">replace</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">,</span>&nbsp;<span>R</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="trait.Replacer.html">Replacer</a></span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>rep</span><span class="ponct">:</span>&nbsp;<span>R</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html">Cow</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">,</span>&nbsp;<span class="primitive">str</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Replaces the leftmost-first match with the replacement provided.
The replacement can be a regular string (where <code>$N</code> and <code>$name</code> are
expanded to match capture groups) or a function that takes the matches’
<code>Captures</code> and returns the replaced string.</p>
<p>If no match is found, then a copy of the string is returned unchanged.</p>
<h2 class="rd-anchor" id="method.replace.replacement-string-syntax">Replacement string syntax<a aria-label="anchor" href="#method.replace.replacement-string-syntax"><i class="bi bi-hash"></i></a></h2>
<p>All instances of <code>$name</code> in the replacement text is replaced with the
corresponding capture group <code>name</code>.</p>
<p><code>name</code> may be an integer corresponding to the index of the
capture group (counted by order of opening parenthesis where <code>0</code> is the
entire match) or it can be a name (consisting of letters, digits or
underscores) corresponding to a named capture group.</p>
<p>If <code>name</code> isn’t a valid capture group (whether the name doesn’t exist
or isn’t a valid index), then it is replaced with the empty string.</p>
<p>The longest possible name is used. e.g., <code>$1a</code> looks up the capture
group named <code>1a</code> and not the capture group at index <code>1</code>. To exert more
precise control over the name, use braces, e.g., <code>${1}a</code>.</p>
<p>To write a literal <code>$</code> use <code>$$</code>.</p>
<h2 class="rd-anchor" id="method.replace.examples">Examples<a aria-label="anchor" href="#method.replace.examples"><i class="bi bi-hash"></i></a></h2>
<p>Note that this function is polymorphic with respect to the replacement.
In typical usage, this can just be a normal string:</p>
<pre><code class="language-rust">let re = Regex::new(&quot;[^01]+&quot;).unwrap();
assert_eq!(re.replace(&quot;1078910&quot;, &quot;&quot;), &quot;1010&quot;);</code></pre>
<p>But anything satisfying the <code>Replacer</code> trait will work. For example,
a closure of type <code>|&amp;Captures| -&gt; String</code> provides direct access to the
captures corresponding to a match. This allows one to access
capturing group matches easily:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;([^,\s]+),\s+(\S+)&quot;).unwrap();
let result = re.replace(&quot;Springsteen, Bruce&quot;, |caps: &amp;Captures| {
    format!(&quot;{} {}&quot;, &amp;caps[2], &amp;caps[1])
});
assert_eq!(result, &quot;Bruce Springsteen&quot;);</code></pre>
<p>But this is a bit cumbersome to use all the time. Instead, a simple
syntax is supported that expands <code>$name</code> into the corresponding capture
group. Here’s the last example, but using this expansion technique
with named capture groups:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?P&lt;last&gt;[^,\s]+),\s+(?P&lt;first&gt;\S+)&quot;).unwrap();
let result = re.replace(&quot;Springsteen, Bruce&quot;, &quot;$first $last&quot;);
assert_eq!(result, &quot;Bruce Springsteen&quot;);</code></pre>
<p>Note that using <code>$2</code> instead of <code>$first</code> or <code>$1</code> instead of <code>$last</code>
would produce the same result. To write a literal <code>$</code> use <code>$$</code>.</p>
<p>Sometimes the replacement string requires use of curly braces to
delineate a capture group replacement and surrounding literal text.
For example, if we wanted to join two words together with an
underscore:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?P&lt;first&gt;\w+)\s+(?P&lt;second&gt;\w+)&quot;).unwrap();
let result = re.replace(&quot;deep fried&quot;, &quot;${first}_$second&quot;);
assert_eq!(result, &quot;deep_fried&quot;);</code></pre>
<p>Without the curly braces, the capture group name <code>first_</code> would be
used, and since it doesn’t exist, it would be replaced with the empty
string.</p>
<p>Finally, sometimes you just want to replace a literal string with no
regard for capturing group expansion. This can be done by wrapping a
byte string with <code>NoExpand</code>:</p>
<pre><code class="language-rust">use regex::NoExpand;

let re = Regex::new(r&quot;(?P&lt;last&gt;[^,\s]+),\s+(\S+)&quot;).unwrap();
let result = re.replace(&quot;Springsteen, Bruce&quot;, NoExpand(&quot;$2 $last&quot;));
assert_eq!(result, &quot;$2 $last&quot;);</code></pre></div></details></div><div id="method.replace_all" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.replace_all">replace_all</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">,</span>&nbsp;<span>R</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="trait.Replacer.html">Replacer</a></span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>rep</span><span class="ponct">:</span>&nbsp;<span>R</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html">Cow</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">,</span>&nbsp;<span class="primitive">str</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Replaces all non-overlapping matches in <code>text</code> with the replacement
provided. This is the same as calling <code>replacen</code> with <code>limit</code> set to
<code>0</code>.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details></div><div id="method.replacen" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.replacen">replacen</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">,</span>&nbsp;<span>R</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="trait.Replacer.html">Replacer</a></span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>limit</span><span class="ponct">:</span>&nbsp;<span class="primitive">usize</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>rep</span><span class="ponct">:</span>&nbsp;<span>R</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html">Cow</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">,</span>&nbsp;<span class="primitive">str</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Replaces at most <code>limit</code> non-overlapping matches in <code>text</code> with the
replacement provided. If <code>limit</code> is 0, then all non-overlapping matches
are replaced.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details></div></div></details></div><div class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"><p>Advanced or “lower level” search methods.</p>
</div><div style="padding-left:1.5rem;"><div id="method.shortest_match" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.shortest_match">shortest_match</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="primitive">usize</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns the end location of a match in the text given.</p>
<p>This method may have the same performance characteristics as
<code>is_match</code>, except it provides an end location for a match. In
particular, the location returned <em>may be shorter</em> than the proper end
of the leftmost-first match.</p>
<h2 class="rd-anchor" id="method.shortest_match.example">Example<a aria-label="anchor" href="#method.shortest_match.example"><i class="bi bi-hash"></i></a></h2>
<p>Typically, <code>a+</code> would match the entire first sequence of <code>a</code> in some
text, but <code>shortest_match</code> can give up as soon as it sees the first
<code>a</code>.</p>
<pre><code class="language-rust">let text = &quot;aaaaa&quot;;
let pos = Regex::new(r&quot;a+&quot;).unwrap().shortest_match(text);
assert_eq!(pos, Some(1));</code></pre></div></details></div><div id="method.shortest_match_at" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.shortest_match_at">shortest_match_at</a></span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>start</span><span class="ponct">:</span>&nbsp;<span class="primitive">usize</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="primitive">usize</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns the same as shortest_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div><div id="method.is_match_at" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.is_match_at">is_match_at</a></span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>start</span><span class="ponct">:</span>&nbsp;<span class="primitive">usize</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="primitive">bool</span></code></summary><div class="mt-2 item-documentation"><p>Returns the same as is_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div><div id="method.find_at" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.find_at">find_at</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>start</span><span class="ponct">:</span>&nbsp;<span class="primitive">usize</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Match.html">Match</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns the same as find, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div><div id="method.captures_read" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.captures_read">captures_read</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>locs</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="kw">mut</span>&nbsp;<span class="ident struct"><a href="struct.CaptureLocations.html">CaptureLocations</a></span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Match.html">Match</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>This is like <code>captures</code>, but uses
<a href="struct.CaptureLocations.html"><code>CaptureLocations</code></a>
instead of
<a href="struct.Captures.html"><code>Captures</code></a> in order to amortize allocations.</p>
<p>To create a <code>CaptureLocations</code> value, use the
<code>Regex::capture_locations</code> method.</p>
<p>This returns the overall match if this was successful, which is always
equivalence to the <code>0</code>th capture group.</p>
</div></details></div><div id="method.captures_read_at" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.captures_read_at">captures_read_at</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">(</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="kw">&</span><span>Self</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>locs</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="kw">mut</span>&nbsp;<span class="ident struct"><a href="struct.CaptureLocations.html">CaptureLocations</a></span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>text</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span>'t</span>&nbsp;<span class="primitive">str</span><span class="ponct">,</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>start</span><span class="ponct">:</span>&nbsp;<span class="primitive">usize</span><br><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html">Option</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Match.html">Match</a></span><span class="ponct">&lt;</span><span>'t</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns the same as captures, but starts the search at the given
offset and populates the capture locations given.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div></div></details></div><div class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"><p>Auxiliary methods.</p>
</div><div style="padding-left:1.5rem;"><div id="method.as_str" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.as_str">as_str</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span></code></summary><div class="mt-2 item-documentation"><p>Returns the original string of this regex.</p>
</div></details></div><div id="method.capture_names" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.capture_names">capture_names</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.CaptureNames.html">CaptureNames</a></span><span class="ponct">&lt;</span><span>'_</span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Returns an iterator over the capture names.</p>
</div></details></div><div id="method.captures_len" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.captures_len">captures_len</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="primitive">usize</span></code></summary><div class="mt-2 item-documentation"><p>Returns the number of captures.</p>
</div></details></div><div id="method.capture_locations" class="mt-2 mb-2 rd-anchor"><details open><summary><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.capture_locations">capture_locations</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.CaptureLocations.html">CaptureLocations</a></span></code></summary><div class="mt-2 item-documentation"><p>Returns an empty set of capture locations that can be reused in
multiple calls to <code>captures_read</code> or <code>captures_read_at</code>.</p>
</div></details></div></div></details></div></section><section><h2 id="trait-implementations" class="rd-anchor">Trait Implementations<a aria-label="anchor" href="#trait-implementations"><i class="bi bi-hash"></i></a></h2><div id="impl-Clone-for-Regex" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html">Clone</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-Clone-for-Regex.method.clone" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.clone">clone</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></div></div></details></div><div id="impl-Debug-for-Regex" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html">Debug</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-Debug-for-Regex.method.fmt" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.fmt">fmt</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>f</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="kw">mut</span>&nbsp;<span class="ident struct"><a href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html">fmt::Formatter</a></span><span class="ponct">&lt;</span><span>'_</span><span class="ponct">&gt;</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident type"><a href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html">fmt::Result</a></span></code></summary><div class="mt-2 item-documentation"><p>Shows the original regular expression.</p>
</div></details></div></div></details></div><div id="impl-Display-for-Regex" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html">Display</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-Display-for-Regex.method.fmt" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.fmt">fmt</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>f</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="kw">mut</span>&nbsp;<span class="ident struct"><a href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html">fmt::Formatter</a></span><span class="ponct">&lt;</span><span>'_</span><span class="ponct">&gt;</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident type"><a href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html">fmt::Result</a></span></code></summary><div class="mt-2 item-documentation"><p>Shows the original regular expression.</p>
</div></details></div></div></details></div><div id="impl-FromStr-for-Regex" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html">FromStr</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-FromStr-for-Regex.type.Err" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">type</span>&nbsp;<span class="ident type"><a href="type.Err.html">Err</a></span>&nbsp;<span class="ponct">=</span>&nbsp;<span class="ident enum"><a href="enum.Error.html">Error</a></span><span class="ponct">;</span></code></div><div id="impl-FromStr-for-Regex.method.from_str" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.from_str">from_str</a></span><span class="ponct">(</span><span>s</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="primitive">str</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a></span><span class="ponct">&lt;</span><span class="ident struct"><a href="struct.Regex.html">Regex</a></span><span class="ponct">,</span>&nbsp;<span class="ident enum"><a href="enum.Error.html">Error</a></span><span class="ponct">&gt;</span></code></summary><div class="mt-2 item-documentation"><p>Attempts to parse a string into a regular expression</p>
</div></details></div></div></details></div></section><section><h2 id="auto-trait-implementations" class="rd-anchor">Auto Trait Implementations<a aria-label="anchor" href="#auto-trait-implementations"><i class="bi bi-hash"></i></a></h2><div id="impl-RefUnwindSafe-for-Regex" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html">RefUnwindSafe</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></div><div id="impl-Send-for-Regex" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html">Send</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></div><div id="impl-Sync-for-Regex" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html">Sync</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></div><div id="impl-Unpin-for-Regex" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html">Unpin</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></div><div id="impl-UnwindSafe-for-Regex" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">impl</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html">UnwindSafe</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span class="ident struct"><a href="struct.Regex.html">Regex</a></span></code></div></section><section><h2 id="blanket-implementations" class="rd-anchor">Blanket Implementations<a aria-label="anchor" href="#blanket-implementations"><i class="bi bi-hash"></i></a></h2><div id="impl-T-Any-for-TwhereT-'static-?Sized" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html">Any</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>T</span><span class="ponct">:</span>&nbsp;<span>'static</span>&nbsp;<span class="ponct">+</span>&nbsp;<span class="kw">?</span><span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html">Sized</a></span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-Any-for-TwhereT-'static-?Sized.method.type_id" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.type_id">type_id</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html">TypeId</a></span></code></div></div></details></div><div id="impl-T-Borrow-T-for-TwhereT-?Sized" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html">Borrow</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>T</span><span class="ponct">:</span>&nbsp;<span class="kw">?</span><span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html">Sized</a></span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-Borrow-T-for-TwhereT-?Sized.method.borrow" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">const</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.borrow">borrow</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">&</span><span>T</span></code></div></div></details></div><div id="impl-T-BorrowMut-T-for-TwhereT-?Sized" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html">BorrowMut</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>T</span><span class="ponct">:</span>&nbsp;<span class="kw">?</span><span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html">Sized</a></span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-BorrowMut-T-for-TwhereT-?Sized.method.borrow_mut" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">const</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.borrow_mut">borrow_mut</a></span><span class="ponct">(</span><span class="kw">&</span><span class="kw">mut</span>&nbsp;<span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">&</span><span class="kw">mut</span>&nbsp;<span>T</span></code></div></div></details></div><div id="impl-T-From-T-for-T" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html">From</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-From-T-for-T.method.from" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">const</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.from">from</a></span><span class="ponct">(</span><span>t</span><span class="ponct">:</span>&nbsp;<span>T</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span>T</span></code></div></div></details></div><div id="impl-T-U-Into-U-for-TwhereU-From-T" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">,</span>&nbsp;<span>U</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html">Into</a></span><span class="ponct">&lt;</span><span>U</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>U</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html">From</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-U-Into-U-for-TwhereU-From-T.method.into" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">const</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.into">into</a></span><span class="ponct">(</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span>U</span></code></div></div></details></div><div id="impl-T-ToOwned-for-TwhereT-Clone" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html">ToOwned</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>T</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html">Clone</a></span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-ToOwned-for-TwhereT-Clone.type.Owned" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">type</span>&nbsp;<span class="ident type"><a href="https://doc.rust-lang.org/nightly/regex/type.Owned.html">Owned</a></span>&nbsp;<span class="ponct">=</span>&nbsp;<span>T</span><span class="ponct">;</span></code></div><div id="impl-T-ToOwned-for-TwhereT-Clone.method.to_owned" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.to_owned">to_owned</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span>T</span></code></div><div id="impl-T-ToOwned-for-TwhereT-Clone.method.clone_into" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.clone_into">clone_into</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">,</span>&nbsp;<span>target</span><span class="ponct">:</span>&nbsp;<span class="kw">&</span><span class="kw">mut</span>&nbsp;<span>T</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ponct">(</span><span class="ponct">)</span></code></div></div></details></div><div id="impl-T-ToString-for-TwhereT-Display-?Sized" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html">ToString</a></span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>T</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html">Display</a></span>&nbsp;<span class="ponct">+</span>&nbsp;<span class="kw">?</span><span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html">Sized</a></span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-ToString-for-TwhereT-Display-?Sized.method.to_string" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.to_string">to_string</a></span><span class="ponct">(</span><span class="kw">&</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident struct"><a href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html">String</a></span></code></div></div></details></div><div id="impl-T-U-TryFrom-U-for-TwhereU-Into-T" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">,</span>&nbsp;<span>U</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html">TryFrom</a></span><span class="ponct">&lt;</span><span>U</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>U</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html">Into</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-U-TryFrom-U-for-TwhereU-Into-T.type.Error" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">type</span>&nbsp;<span class="ident type"><a href="https://doc.rust-lang.org/nightly/regex/type.Error.html">Error</a></span>&nbsp;<span class="ponct">=</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html">Infallible</a></span><span class="ponct">;</span></code></div><div id="impl-T-U-TryFrom-U-for-TwhereU-Into-T.method.try_from" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.try_from">try_from</a></span><span class="ponct">(</span><span>value</span><span class="ponct">:</span>&nbsp;<span>U</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">,</span>&nbsp;<span class="ponct">&lt;</span><span>T</span>&nbsp;<span class="kw">as</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html">TryFrom</a></span><span class="ponct">&lt;</span><span>U</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span><span class="ponct">::</span><span>Error</span><span class="ponct">&gt;</span></code></div></div></details></div><div id="impl-T-U-TryInto-U-for-TwhereU-TryFrom-T" class="mt-2 mb-2 rd-anchor"><details><summary><code class="inline-code"><span class="kw">impl</span><span class="ponct">&lt;</span><span>T</span><span class="ponct">,</span>&nbsp;<span>U</span><span class="ponct">&gt;</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html">TryInto</a></span><span class="ponct">&lt;</span><span>U</span><span class="ponct">&gt;</span>&nbsp;<span class="kw">for</span>&nbsp;<span>T</span><br><span class="where-clause"><span class="kw">where</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span>U</span><span class="ponct">:</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html">TryFrom</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span><span class="ponct">,</span></span></code></summary><div class="mt-2 item-documentation"></div><div style="padding-left:1.5rem;"><div id="impl-T-U-TryInto-U-for-TwhereU-TryFrom-T.type.Error" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">type</span>&nbsp;<span class="ident type"><a href="https://doc.rust-lang.org/nightly/regex/type.Error.html">Error</a></span>&nbsp;<span class="ponct">=</span>&nbsp;<span class="ponct">&lt;</span><span>U</span>&nbsp;<span class="kw">as</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html">TryFrom</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span><span class="ponct">::</span><span>Error</span><span class="ponct">;</span></code></div><div id="impl-T-U-TryInto-U-for-TwhereU-TryFrom-T.method.try_into" class="mt-2 mb-2 rd-anchor"><code class="inline-code"><span class="kw">pub</span>&nbsp;<span class="kw">fn</span>&nbsp;<span class="ident method"><a href="#method.try_into">try_into</a></span><span class="ponct">(</span><span>Self</span><span class="ponct">)</span>&nbsp;<span class="ponct">-</span><span class="ponct">&gt;</span>&nbsp;<span class="ident enum"><a href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html">Result</a></span><span class="ponct">&lt;</span><span>U</span><span class="ponct">,</span>&nbsp;<span class="ponct">&lt;</span><span>U</span>&nbsp;<span class="kw">as</span>&nbsp;<span class="ident trait"><a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html">TryFrom</a></span><span class="ponct">&lt;</span><span>T</span><span class="ponct">&gt;</span><span class="ponct">&gt;</span><span class="ponct">::</span><span>Error</span><span class="ponct">&gt;</span></code></div></div></details></div></section></div></div></div><footer class="container-xxl text-center">The rd developpers - (c) 2022</footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.min.js" integrity="sha384-cn7l7gDp0eyniUwwAZgrzD06kc/tftFf19TOAs2zVinnD/C7E91j9yyk5//jjpt/" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap-dark-5@1.1.3/dist/js/darkmode.min.js" integrity="sha384-A4SLs39X/aUfwRclRaXvNeXNBTLZdnZdHhhteqbYFS2jZTRD79tKeFeBn7SGXNpi" crossorigin="anonymous"></script><script src="../regex/search-index.js"></script><script src="../search.js"></script></body></html>
