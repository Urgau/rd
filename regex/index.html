<!DOCTYPE html><html lang="en" data-bs-color-scheme="light"><head><title>regex - Rust</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="color-scheme" content="light dark"><link href="https://cdn.jsdelivr.net/npm/bootstrap-dark-5@1.1.3/dist/css/bootstrap-blackbox.min.css" integrity="sha384-nXtYGwAUBOgb4M8Eo9xOK3Er3bVPQo1HguUNWf/RheIagsbCaP3ZaYqVeUqHEr20" rel="stylesheet" crossorigin="anonymous"><link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" integrity="sha384-tKLJeE1ALTUwtXlaGjJYM3sejfssWdAaWR2s97axw4xkiAdMzQjtOjgcyw0Y50KU" rel="stylesheet" crossorigin="anonymous"><link href="../style.css" rel="stylesheet"><link href="../rust.svg" rel="icon" type="image/svg+xml"></head><body><header class="navbar navbar-expand-md navbar-dark rd-navbar"><nav class="container-xxl flex-wrap flex-md-nowrap" aria-label="Main navigation"><a class="navbar-brand p-0 me-2" href="../regex/index.html" aria-label="Rust"><img src="../rust.svg" width="40" height="40" alt="Rust Logo"></a><button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#rdNavbar" aria-controls="rdNavbar" aria-expanded="false" aria-label="Toggle navigation"><i class="bi bi-list"></i></button><div class="collapse navbar-collapse" id="rdNavbar"><ul class="navbar-nav flex-row flex-wrap pt-2 py-md-0"><li class="nav-item col-6 col-md-auto"><a class="nav-link p-2 active" href="../regex/index.html">regex</a></li></ul><hr class="d-md-none text-white-50"><ul class="navbar-nav flex-row flex-wrap ms-md-auto"><li class="nav-item col-6 col-md-auto"><a class="nav-link p-2" href="#themes" title="Toggle themes" onclick="darkmode.toggleDarkMode()"><i class="bi bi-palette"></i><small class="d-md-none ms-2">Themes</small></a></li><li class="nav-item col-6 col-md-auto" title="Unimplemented"><a class="nav-link p-2" href="#shortcuts"><i class="bi bi-question-lg"></i><small class="d-md-none ms-2">Shortcut</small></a></li><li class="nav-item col-6 col-md-auto" title="Unimplemented"><a class="nav-link p-2" href="#options"><i class="bi bi-wrench"></i><small class="d-md-none ms-2">Options</small></a></li></ul></div></nav></header><nav class="rd-subnavbar py-2 border-bottom shadow-sm" aria-label="Secondary navigation"><div class="container-xxl d-flex align-items-md-center"><form class="rd-search position-relative" id="rd-search-form"><span class="w-100" style="position: relative; display: inline-block; direction: ltr;"><input type="search" class="form-control ds-input" id="rd-search-input" placeholder="Search in regex..." aria-label="Search docs for..." autocomplete="off" spellcheck="false" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-owns="rd-search-menu" style="position: relative; vertical-align: top;" dir="auto"><span class="ds-dropdown-menu" style="position: absolute; top: 100%; z-index: 100; display: none; left: 0px; right: 0px;" role="listbox" id="rd-search-menu"><div class="rd-search-items" id="rd-search-items"></div></span></span></form><button class="btn rd-sidebar-toggle d-md-none py-0 px-1 ms-3 order-3 collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#rd-docs-nav" aria-controls="rd-docs-nav" aria-expanded="false" aria-label="Toggle docs navigation"><i class="bi bi-arrows-expand"></i><i class="bi bi-arrows-collapse"></i></button></div></nav><div id="main" class="container-xxl"><div class="rd-main"><div class="rd-intro"><h1 id="item-title" class="rd-anchor item-title">Crate <a class="mod" href="index.html">regex</a></h1><details id="item-documentation" class="rd-anchor item-documentation" open=""><summary>Documentation</summary><div class="mt-2"><p>This crate provides a library for parsing, compiling, and executing regular
expressions. Its syntax is similar to Perl-style regular expressions, but lacks
a few features like look around and backreferences. In exchange, all searches
execute in linear time with respect to the size of the regular expression and
search text.</p>
<p>This crate’s documentation provides some simple examples, describes
<a href="#unicode">Unicode support</a> and exhaustively lists the
<a href="#syntax">supported syntax</a>.</p>
<p>For more specific details on the API for regular expressions, please see the
documentation for the <a href="struct.Regex.html"><code>Regex</code></a> type.</p>
<h2 class="rd-anchor" id="usage">Usage<a aria-label="anchor" href="#usage"><i class="bi bi-hash"></i></a></h2>
<p>This crate is <a href="https://crates.io/crates/regex">on crates.io</a> and can be
used by adding <code>regex</code> to your dependencies in your project’s <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1&quot;
</code></pre>
<h2 class="rd-anchor" id="example-find-a-date">Example: find a date<a aria-label="anchor" href="#example-find-a-date"><i class="bi bi-hash"></i></a></h2>
<p>General use of regular expressions in this package involves compiling an
expression and then using it to search, split or replace text. For example,
to confirm that some text resembles a date:</p>
<pre><code class="language-rust">use regex::Regex;
let re = Regex::new(r&quot;^\d{4}-\d{2}-\d{2}$&quot;).unwrap();
assert!(re.is_match(&quot;2014-01-01&quot;));</code></pre>
<p>Notice the use of the <code>^</code> and <code>$</code> anchors. In this crate, every expression
is executed with an implicit <code>.*?</code> at the beginning and end, which allows
it to match anywhere in the text. Anchors can be used to ensure that the
full text matches an expression.</p>
<p>This example also demonstrates the utility of
<a href="https://doc.rust-lang.org/stable/reference/tokens.html#raw-string-literals">raw strings</a>
in Rust, which
are just like regular strings except they are prefixed with an <code>r</code> and do
not process any escape sequences. For example, <code>&quot;\\d&quot;</code> is the same
expression as <code>r&quot;\d&quot;</code>.</p>
<h2 class="rd-anchor" id="example-avoid-compiling-the-same-regex-in-a-loop">Example: Avoid compiling the same regex in a loop<a aria-label="anchor" href="#example-avoid-compiling-the-same-regex-in-a-loop"><i class="bi bi-hash"></i></a></h2>
<p>It is an anti-pattern to compile the same regular expression in a loop
since compilation is typically expensive. (It takes anywhere from a few
microseconds to a few <strong>milliseconds</strong> depending on the size of the
regex.) Not only is compilation itself expensive, but this also prevents
optimizations that reuse allocations internally to the matching engines.</p>
<p>In Rust, it can sometimes be a pain to pass regular expressions around if
they’re used from inside a helper function. Instead, we recommend using the
<a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> crate to ensure that
regular expressions are compiled exactly once.</p>
<p>For example:</p>
<pre><code class="language-rust">use lazy_static::lazy_static;
use regex::Regex;

fn some_helper_function(text: &amp;str) -&gt; bool {
    lazy_static! {
        static ref RE: Regex = Regex::new(&quot;...&quot;).unwrap();
    }
    RE.is_match(text)
}

fn main() {}</code></pre>
<p>Specifically, in this example, the regex will be compiled when it is used for
the first time. On subsequent uses, it will reuse the previous compilation.</p>
<h2 class="rd-anchor" id="example-iterating-over-capture-groups">Example: iterating over capture groups<a aria-label="anchor" href="#example-iterating-over-capture-groups"><i class="bi bi-hash"></i></a></h2>
<p>This crate provides convenient iterators for matching an expression
repeatedly against a search string to find successive non-overlapping
matches. For example, to find all dates in a string and be able to access
them by their component pieces:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(\d{4})-(\d{2})-(\d{2})&quot;).unwrap();
let text = &quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;;
for cap in re.captures_iter(text) {
    println!(&quot;Month: {} Day: {} Year: {}&quot;, &amp;cap[2], &amp;cap[3], &amp;cap[1]);
}
// Output:
// Month: 03 Day: 14 Year: 2012
// Month: 01 Day: 01 Year: 2013
// Month: 07 Day: 05 Year: 2014</code></pre>
<p>Notice that the year is in the capture group indexed at <code>1</code>. This is
because the <em>entire match</em> is stored in the capture group at index <code>0</code>.</p>
<h2 class="rd-anchor" id="example-replacement-with-named-capture-groups">Example: replacement with named capture groups<a aria-label="anchor" href="#example-replacement-with-named-capture-groups"><i class="bi bi-hash"></i></a></h2>
<p>Building on the previous example, perhaps we’d like to rearrange the date
formats. This can be done with text replacement. But to make the code
clearer, we can <em>name</em>  our capture groups and use those names as variables
in our replacement text:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?P&lt;y&gt;\d{4})-(?P&lt;m&gt;\d{2})-(?P&lt;d&gt;\d{2})&quot;).unwrap();
let before = &quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;;
let after = re.replace_all(before, &quot;$m/$d/$y&quot;);
assert_eq!(after, &quot;03/14/2012, 01/01/2013 and 07/05/2014&quot;);</code></pre>
<p>The <code>replace</code> methods are actually polymorphic in the replacement, which
provides more flexibility than is seen here. (See the documentation for
<code>Regex::replace</code> for more details.)</p>
<p>Note that if your regex gets complicated, you can use the <code>x</code> flag to
enable insignificant whitespace mode, which also lets you write comments:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?x)
  (?P&lt;y&gt;\d{4}) # the year
  -
  (?P&lt;m&gt;\d{2}) # the month
  -
  (?P&lt;d&gt;\d{2}) # the day
&quot;).unwrap();
let before = &quot;2012-03-14, 2013-01-01 and 2014-07-05&quot;;
let after = re.replace_all(before, &quot;$m/$d/$y&quot;);
assert_eq!(after, &quot;03/14/2012, 01/01/2013 and 07/05/2014&quot;);</code></pre>
<p>If you wish to match against whitespace in this mode, you can still use <code>\s</code>,
<code>\n</code>, <code>\t</code>, etc. For escaping a single space character, you can escape it
directly with <code>\ </code>, use its hex character code <code>\x20</code> or temporarily disable
the <code>x</code> flag, e.g., <code>(?-x: )</code>.</p>
<h2 class="rd-anchor" id="example-match-multiple-regular-expressions-simultaneously">Example: match multiple regular expressions simultaneously<a aria-label="anchor" href="#example-match-multiple-regular-expressions-simultaneously"><i class="bi bi-hash"></i></a></h2>
<p>This demonstrates how to use a <code>RegexSet</code> to match multiple (possibly
overlapping) regular expressions in a single scan of the search text:</p>
<pre><code class="language-rust">use regex::RegexSet;

let set = RegexSet::new(&amp;[
    r&quot;\w+&quot;,
    r&quot;\d+&quot;,
    r&quot;\pL+&quot;,
    r&quot;foo&quot;,
    r&quot;bar&quot;,
    r&quot;barfoo&quot;,
    r&quot;foobar&quot;,
]).unwrap();

// Iterate over and collect all of the matches.
let matches: Vec&lt;_&gt; = set.matches(&quot;foobar&quot;).into_iter().collect();
assert_eq!(matches, vec![0, 2, 3, 4, 6]);

// You can also test whether a particular regex matched:
let matches = set.matches(&quot;foobar&quot;);
assert!(!matches.matched(5));
assert!(matches.matched(6));</code></pre><h2 class="rd-anchor" id="pay-for-what-you-use">Pay for what you use<a aria-label="anchor" href="#pay-for-what-you-use"><i class="bi bi-hash"></i></a></h2>
<p>With respect to searching text with a regular expression, there are three
questions that can be asked:</p>
<ol>
<li>Does the text match this expression?</li>
<li>If so, where does it match?</li>
<li>Where did the capturing groups match?</li>
</ol>
<p>Generally speaking, this crate could provide a function to answer only #3,
which would subsume #1 and #2 automatically. However, it can be significantly
more expensive to compute the location of capturing group matches, so it’s best
not to do it if you don’t need to.</p>
<p>Therefore, only use what you need. For example, don’t use <code>find</code> if you
only need to test if an expression matches a string. (Use <code>is_match</code>
instead.)</p>
<h2 class="rd-anchor" id="unicode">Unicode<a aria-label="anchor" href="#unicode"><i class="bi bi-hash"></i></a></h2>
<p>This implementation executes regular expressions <strong>only</strong> on valid UTF-8
while exposing match locations as byte indices into the search string. (To
relax this restriction, use the <a href="bytes/index.html"><code>bytes</code></a> sub-module.)</p>
<p>Only simple case folding is supported. Namely, when matching
case-insensitively, the characters are first mapped using the “simple” case
folding rules defined by Unicode.</p>
<p>Regular expressions themselves are <strong>only</strong> interpreted as a sequence of
Unicode scalar values. This means you can use Unicode characters directly
in your expression:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?i)Δ+&quot;).unwrap();
let mat = re.find(&quot;ΔδΔ&quot;).unwrap();
assert_eq!((mat.start(), mat.end()), (0, 6));</code></pre>
<p>Most features of the regular expressions in this crate are Unicode aware. Here
are some examples:</p>
<ul>
<li><code>.</code> will match any valid UTF-8 encoded Unicode scalar value except for <code>\n</code>.
(To also match <code>\n</code>, enable the <code>s</code> flag, e.g., <code>(?s:.)</code>.)</li>
<li><code>\w</code>, <code>\d</code> and <code>\s</code> are Unicode aware. For example, <code>\s</code> will match all forms
of whitespace categorized by Unicode.</li>
<li><code>\b</code> matches a Unicode word boundary.</li>
<li>Negated character classes like <code>[^a]</code> match all Unicode scalar values except
for <code>a</code>.</li>
<li><code>^</code> and <code>$</code> are <strong>not</strong> Unicode aware in multi-line mode. Namely, they only
recognize <code>\n</code> and not any of the other forms of line terminators defined
by Unicode.</li>
</ul>
<p>Unicode general categories, scripts, script extensions, ages and a smattering
of boolean properties are available as character classes. For example, you can
match a sequence of numerals, Greek or Cherokee letters:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;[\pN\p{Greek}\p{Cherokee}]+&quot;).unwrap();
let mat = re.find(&quot;abcΔᎠβⅠᏴγδⅡxyz&quot;).unwrap();
assert_eq!((mat.start(), mat.end()), (3, 23));</code></pre>
<p>For a more detailed breakdown of Unicode support with respect to
<a href="https://unicode.org/reports/tr18/">UTS#18</a>,
please see the
<a href="https://github.com/rust-lang/regex/blob/master/UNICODE.md">UNICODE</a>
document in the root of the regex repository.</p>
<h2 class="rd-anchor" id="opt-out-of-unicode-support">Opt out of Unicode support<a aria-label="anchor" href="#opt-out-of-unicode-support"><i class="bi bi-hash"></i></a></h2>
<p>The <code>bytes</code> sub-module provides a <code>Regex</code> type that can be used to match
on <code>&amp;[u8]</code>. By default, text is interpreted as UTF-8 just like it is with
the main <code>Regex</code> type. However, this behavior can be disabled by turning
off the <code>u</code> flag, even if doing so could result in matching invalid UTF-8.
For example, when the <code>u</code> flag is disabled, <code>.</code> will match any byte instead
of any Unicode scalar value.</p>
<p>Disabling the <code>u</code> flag is also possible with the standard <code>&amp;str</code>-based <code>Regex</code>
type, but it is only allowed where the UTF-8 invariant is maintained. For
example, <code>(?-u:\w)</code> is an ASCII-only <code>\w</code> character class and is legal in an
<code>&amp;str</code>-based <code>Regex</code>, but <code>(?-u:\xFF)</code> will attempt to match the raw byte
<code>\xFF</code>, which is invalid UTF-8 and therefore is illegal in <code>&amp;str</code>-based
regexes.</p>
<p>Finally, since Unicode support requires bundling large Unicode data
tables, this crate exposes knobs to disable the compilation of those
data tables, which can be useful for shrinking binary size and reducing
compilation times. For details on how to do that, see the section on <a href="#crate-features">crate
features</a>.</p>
<h2 class="rd-anchor" id="syntax">Syntax<a aria-label="anchor" href="#syntax"><i class="bi bi-hash"></i></a></h2>
<p>The syntax supported in this crate is documented below.</p>
<p>Note that the regular expression parser and abstract syntax are exposed in
a separate crate, <a href="https://docs.rs/regex-syntax"><code>regex-syntax</code></a>.</p>
<h3 class="rd-anchor" id="matching-one-character">Matching one character<a aria-label="anchor" href="#matching-one-character"><i class="bi bi-hash"></i></a></h3><pre class="rust">
.             any character except new line (includes new line with s flag)
\d            digit (\p{Nd})
\D            not digit
\pN           One-letter name Unicode character class
\p{Greek}     Unicode character class (general category or script)
\PN           Negated one-letter name Unicode character class
\P{Greek}     negated Unicode character class (general category or script)
</pre>
<h4 class="rd-anchor" id="character-classes">Character classes<a aria-label="anchor" href="#character-classes"><i class="bi bi-hash"></i></a></h4><pre class="rust">
[xyz]         A character class matching either x, y or z (union).
[^xyz]        A character class matching any character except x, y and z.
[a-z]         A character class matching any character in range a-z.
[[:alpha:]]   ASCII character class ([A-Za-z])
[[:^alpha:]]  Negated ASCII character class ([^A-Za-z])
[x[^xyz]]     Nested/grouping character class (matching any character except y and z)
[a-y&&xyz]    Intersection (matching x or y)
[0-9&&[^4]]   Subtraction using intersection and negation (matching 0-9 except 4)
[0-9--4]      Direct subtraction (matching 0-9 except 4)
[a-g~~b-h]    Symmetric difference (matching `a` and `h` only)
[\[\]]        Escaping in character classes (matching [ or ])
</pre>
<p>Any named character class may appear inside a bracketed <code>[...]</code> character
class. For example, <code>[\p{Greek}[:digit:]]</code> matches any Greek or ASCII
digit. <code>[\p{Greek}&amp;&amp;\pL]</code> matches Greek letters.</p>
<p>Precedence in character classes, from most binding to least:</p>
<ol>
<li>Ranges: <code>a-cd</code> == <code>[a-c]d</code></li>
<li>Union: <code>ab&amp;&amp;bc</code> == <code>[ab]&amp;&amp;[bc]</code></li>
<li>Intersection: <code>^a-z&amp;&amp;b</code> == <code>^[a-z&amp;&amp;b]</code></li>
<li>Negation</li>
</ol>
<h3 class="rd-anchor" id="composites">Composites<a aria-label="anchor" href="#composites"><i class="bi bi-hash"></i></a></h3><pre class="rust">
xy    concatenation (x followed by y)
x|y   alternation (x or y, prefer x)
</pre>
<h3 class="rd-anchor" id="repetitions">Repetitions<a aria-label="anchor" href="#repetitions"><i class="bi bi-hash"></i></a></h3><pre class="rust">
x*        zero or more of x (greedy)
x+        one or more of x (greedy)
x?        zero or one of x (greedy)
x*?       zero or more of x (ungreedy/lazy)
x+?       one or more of x (ungreedy/lazy)
x??       zero or one of x (ungreedy/lazy)
x{n,m}    at least n x and at most m x (greedy)
x{n,}     at least n x (greedy)
x{n}      exactly n x
x{n,m}?   at least n x and at most m x (ungreedy/lazy)
x{n,}?    at least n x (ungreedy/lazy)
x{n}?     exactly n x
</pre>
<h3 class="rd-anchor" id="empty-matches">Empty matches<a aria-label="anchor" href="#empty-matches"><i class="bi bi-hash"></i></a></h3><pre class="rust">
^     the beginning of text (or start-of-line with multi-line mode)
$     the end of text (or end-of-line with multi-line mode)
\A    only the beginning of text (even with multi-line mode enabled)
\z    only the end of text (even with multi-line mode enabled)
\b    a Unicode word boundary (\w on one side and \W, \A, or \z on other)
\B    not a Unicode word boundary
</pre>
<h3 class="rd-anchor" id="grouping-and-flags">Grouping and flags<a aria-label="anchor" href="#grouping-and-flags"><i class="bi bi-hash"></i></a></h3><pre class="rust">
(exp)          numbered capture group (indexed by opening parenthesis)
(?P&lt;name&gt;exp)  named (also numbered) capture group (allowed chars: [_0-9a-zA-Z.\[\]])
(?:exp)        non-capturing group
(?flags)       set flags within current group
(?flags:exp)   set flags for exp (non-capturing)
</pre>
<p>Flags are each a single character. For example, <code>(?x)</code> sets the flag <code>x</code>
and <code>(?-x)</code> clears the flag <code>x</code>. Multiple flags can be set or cleared at
the same time: <code>(?xy)</code> sets both the <code>x</code> and <code>y</code> flags and <code>(?x-y)</code> sets
the <code>x</code> flag and clears the <code>y</code> flag.</p>
<p>All flags are by default disabled unless stated otherwise. They are:</p>
<pre class="rust">
i     case-insensitive: letters match both upper and lower case
m     multi-line mode: ^ and $ match begin/end of line
s     allow . to match \n
U     swap the meaning of x* and x*?
u     Unicode support (enabled by default)
x     ignore whitespace and allow line comments (starting with `#`)
</pre>
<p>Flags can be toggled within a pattern. Here’s an example that matches
case-insensitively for the first part but case-sensitively for the second part:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?i)a+(?-i)b+&quot;).unwrap();
let cap = re.captures(&quot;AaAaAbbBBBb&quot;).unwrap();
assert_eq!(&amp;cap[0], &quot;AaAaAbb&quot;);</code></pre>
<p>Notice that the <code>a+</code> matches either <code>a</code> or <code>A</code>, but the <code>b+</code> only matches
<code>b</code>.</p>
<p>Multi-line mode means <code>^</code> and <code>$</code> no longer match just at the beginning/end of
the input, but at the beginning/end of lines:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?m)^line \d+&quot;).unwrap();
let m = re.find(&quot;line one\nline 2\n&quot;).unwrap();
assert_eq!(m.as_str(), &quot;line 2&quot;);</code></pre>
<p>Note that <code>^</code> matches after new lines, even at the end of input:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?m)^&quot;).unwrap();
let m = re.find_iter(&quot;test\n&quot;).last().unwrap();
assert_eq!((m.start(), m.end()), (5, 5));</code></pre>
<p>Here is an example that uses an ASCII word boundary instead of a Unicode
word boundary:</p>
<pre><code class="language-rust">let re = Regex::new(r&quot;(?-u:\b).+(?-u:\b)&quot;).unwrap();
let cap = re.captures(&quot;$$abc$$&quot;).unwrap();
assert_eq!(&amp;cap[0], &quot;abc&quot;);</code></pre><h3 class="rd-anchor" id="escape-sequences">Escape sequences<a aria-label="anchor" href="#escape-sequences"><i class="bi bi-hash"></i></a></h3><pre class="rust">
\*          literal *, works for any punctuation character: \.+*?()|[]{}^$
\a          bell (\x07)
\f          form feed (\x0C)
\t          horizontal tab
\n          new line
\r          carriage return
\v          vertical tab (\x0B)
\123        octal character code (up to three digits) (when enabled)
\x7F        hex character code (exactly two digits)
\x{10FFFF}  any hex character code corresponding to a Unicode code point
\u007F      hex character code (exactly four digits)
\u{7F}      any hex character code corresponding to a Unicode code point
\U0000007F  hex character code (exactly eight digits)
\U{7F}      any hex character code corresponding to a Unicode code point
</pre>
<h3 class="rd-anchor" id="perl-character-classes-unicode-friendly">Perl character classes (Unicode friendly)<a aria-label="anchor" href="#perl-character-classes-unicode-friendly"><i class="bi bi-hash"></i></a></h3>
<p>These classes are based on the definitions provided in
<a href="https://www.unicode.org/reports/tr18/#Compatibility_Properties">UTS#18</a>:</p>
<pre class="rust">
\d     digit (\p{Nd})
\D     not digit
\s     whitespace (\p{White_Space})
\S     not whitespace
\w     word character (\p{Alphabetic} + \p{M} + \d + \p{Pc} + \p{Join_Control})
\W     not word character
</pre>
<h3 class="rd-anchor" id="ascii-character-classes">ASCII character classes<a aria-label="anchor" href="#ascii-character-classes"><i class="bi bi-hash"></i></a></h3><pre class="rust">
[[:alnum:]]    alphanumeric ([0-9A-Za-z])
[[:alpha:]]    alphabetic ([A-Za-z])
[[:ascii:]]    ASCII ([\x00-\x7F])
[[:blank:]]    blank ([\t ])
[[:cntrl:]]    control ([\x00-\x1F\x7F])
[[:digit:]]    digits ([0-9])
[[:graph:]]    graphical ([!-~])
[[:lower:]]    lower case ([a-z])
[[:print:]]    printable ([ -~])
[[:punct:]]    punctuation ([!-/:-@\[-`{-~])
[[:space:]]    whitespace ([\t\n\v\f\r ])
[[:upper:]]    upper case ([A-Z])
[[:word:]]     word characters ([0-9A-Za-z_])
[[:xdigit:]]   hex digit ([0-9A-Fa-f])
</pre>
<h2 class="rd-anchor" id="crate-features">Crate features<a aria-label="anchor" href="#crate-features"><i class="bi bi-hash"></i></a></h2>
<p>By default, this crate tries pretty hard to make regex matching both as fast
as possible and as correct as it can be, within reason. This means that there
is a lot of code dedicated to performance, the handling of Unicode data and the
Unicode data itself. Overall, this leads to more dependencies, larger binaries
and longer compile times.  This trade off may not be appropriate in all cases,
and indeed, even when all Unicode and performance features are disabled, one
is still left with a perfectly serviceable regex engine that will work well
in many cases.</p>
<p>This crate exposes a number of features for controlling that trade off. Some
of these features are strictly performance oriented, such that disabling them
won’t result in a loss of functionality, but may result in worse performance.
Other features, such as the ones controlling the presence or absence of Unicode
data, can result in a loss of functionality. For example, if one disables the
<code>unicode-case</code> feature (described below), then compiling the regex <code>(?i)a</code>
will fail since Unicode case insensitivity is enabled by default. Instead,
callers must use <code>(?i-u)a</code> instead to disable Unicode case folding. Stated
differently, enabling or disabling any of the features below can only add or
subtract from the total set of valid regular expressions. Enabling or disabling
a feature will never modify the match semantics of a regular expression.</p>
<p>All features below are enabled by default.</p>
<h4 class="rd-anchor" id="ecosystem-features">Ecosystem features<a aria-label="anchor" href="#ecosystem-features"><i class="bi bi-hash"></i></a></h4>
<ul>
<li><strong>std</strong> -
When enabled, this will cause <code>regex</code> to use the standard library. Currently,
disabling this feature will always result in a compilation error. It is
intended to add <code>alloc</code>-only support to regex in the future.</li>
</ul>
<h4 class="rd-anchor" id="performance-features">Performance features<a aria-label="anchor" href="#performance-features"><i class="bi bi-hash"></i></a></h4>
<ul>
<li><strong>perf</strong> -
Enables all performance related features. This feature is enabled by default
and will always cover all features that improve performance, even if more
are added in the future.</li>
<li><strong>perf-dfa</strong> -
Enables the use of a lazy DFA for matching. The lazy DFA is used to compile
portions of a regex to a very fast DFA on an as-needed basis. This can
result in substantial speedups, usually by an order of magnitude on large
haystacks. The lazy DFA does not bring in any new dependencies, but it can
make compile times longer.</li>
<li><strong>perf-inline</strong> -
Enables the use of aggressive inlining inside match routines. This reduces
the overhead of each match. The aggressive inlining, however, increases
compile times and binary size.</li>
<li><strong>perf-literal</strong> -
Enables the use of literal optimizations for speeding up matches. In some
cases, literal optimizations can result in speedups of <em>several</em> orders of
magnitude. Disabling this drops the <code>aho-corasick</code> and <code>memchr</code> dependencies.</li>
<li><strong>perf-cache</strong> -
This feature used to enable a faster internal cache at the cost of using
additional dependencies, but this is no longer an option. A fast internal
cache is now used unconditionally with no additional dependencies. This may
change in the future.</li>
</ul>
<h4 class="rd-anchor" id="unicode-features">Unicode features<a aria-label="anchor" href="#unicode-features"><i class="bi bi-hash"></i></a></h4>
<ul>
<li><strong>unicode</strong> -
Enables all Unicode features. This feature is enabled by default, and will
always cover all Unicode features, even if more are added in the future.</li>
<li><strong>unicode-age</strong> -
Provide the data for the
<a href="https://www.unicode.org/reports/tr44/tr44-24.html#Character_Age">Unicode <code>Age</code> property</a>.
This makes it possible to use classes like <code>\p{Age:6.0}</code> to refer to all
codepoints first introduced in Unicode 6.0</li>
<li><strong>unicode-bool</strong> -
Provide the data for numerous Unicode boolean properties. The full list
is not included here, but contains properties like <code>Alphabetic</code>, <code>Emoji</code>,
<code>Lowercase</code>, <code>Math</code>, <code>Uppercase</code> and <code>White_Space</code>.</li>
<li><strong>unicode-case</strong> -
Provide the data for case insensitive matching using
<a href="https://www.unicode.org/reports/tr18/#Simple_Loose_Matches">Unicode’s “simple loose matches” specification</a>.</li>
<li><strong>unicode-gencat</strong> -
Provide the data for
<a href="https://www.unicode.org/reports/tr44/tr44-24.html#General_Category_Values">Unicode general categories</a>.
This includes, but is not limited to, <code>Decimal_Number</code>, <code>Letter</code>,
<code>Math_Symbol</code>, <code>Number</code> and <code>Punctuation</code>.</li>
<li><strong>unicode-perl</strong> -
Provide the data for supporting the Unicode-aware Perl character classes,
corresponding to <code>\w</code>, <code>\s</code> and <code>\d</code>. This is also necessary for using
Unicode-aware word boundary assertions. Note that if this feature is
disabled, the <code>\s</code> and <code>\d</code> character classes are still available if the
<code>unicode-bool</code> and <code>unicode-gencat</code> features are enabled, respectively.</li>
<li><strong>unicode-script</strong> -
Provide the data for
<a href="https://www.unicode.org/reports/tr24/">Unicode scripts and script extensions</a>.
This includes, but is not limited to, <code>Arabic</code>, <code>Cyrillic</code>, <code>Hebrew</code>,
<code>Latin</code> and <code>Thai</code>.</li>
<li><strong>unicode-segment</strong> -
Provide the data necessary to provide the properties used to implement the
<a href="https://www.unicode.org/reports/tr29/">Unicode text segmentation algorithms</a>.
This enables using classes like <code>\p{gcb=Extend}</code>, <code>\p{wb=Katakana}</code> and
<code>\p{sb=ATerm}</code>.</li>
</ul>
<h2 class="rd-anchor" id="untrusted-input">Untrusted input<a aria-label="anchor" href="#untrusted-input"><i class="bi bi-hash"></i></a></h2>
<p>This crate can handle both untrusted regular expressions and untrusted
search text.</p>
<p>Untrusted regular expressions are handled by capping the size of a compiled
regular expression.
(See <a href="struct.RegexBuilder.html#method.size_limit"><code>RegexBuilder::size_limit</code></a>.)
Without this, it would be trivial for an attacker to exhaust your system’s
memory with expressions like <code>a{100}{100}{100}</code>.</p>
<p>Untrusted search text is allowed because the matching engine(s) in this
crate have time complexity <code>O(mn)</code> (with <code>m ~ regex</code> and <code>n ~ search text</code>), which means there’s no way to cause exponential blow-up like with
some other regular expression engines. (We pay for this by disallowing
features like arbitrary look-ahead and backreferences.)</p>
<p>When a DFA is used, pathological cases with exponential state blow-up are
avoided by constructing the DFA lazily or in an “online” manner. Therefore,
at most one new state can be created for each byte of input. This satisfies
our time complexity guarantees, but can lead to memory growth
proportional to the size of the input. As a stopgap, the DFA is only
allowed to store a fixed number of states. When the limit is reached, its
states are wiped and continues on, possibly duplicating previous work. If
the limit is reached too frequently, it gives up and hands control off to
another matching engine with fixed memory requirements.
(The DFA size limit can also be tweaked. See
<a href="struct.RegexBuilder.html#method.dfa_size_limit"><code>RegexBuilder::dfa_size_limit</code></a>.)</p>
</div></details></div><div id="rd-docs-nav" class="rd-toc ps-xl-3 collapse"><strong class="d-block h6 my-2 pb-2 border-bottom">On this page</strong><nav id="TableOfContents"><ul><li><a href="#item-title" class="d-inline-flex align-items-center rounded"><strong>regex</strong></a></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#item-documentation" data-bs-toggle="collapse" data-bs-target="#toc-documentation" aria-expanded="true" aria-current="true"><strong>Documentation</strong></a><ul id="toc-documentation" class="collapse show"></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#modules" data-bs-toggle="collapse" data-bs-target="#toc-modules" aria-expanded="true" aria-current="true"><strong>Modules</strong></a><ul id="toc-modules" class="collapse show"><li><a href="bytes/index.html" class="d-inline-block align-items-center rounded">bytes</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#structs" data-bs-toggle="collapse" data-bs-target="#toc-structs" aria-expanded="true" aria-current="true"><strong>Structs</strong></a><ul id="toc-structs" class="collapse show"><li><a href="struct.CaptureLocations.html" class="d-inline-block align-items-center rounded">CaptureLocations</a></li><li><a href="struct.CaptureMatches.html" class="d-inline-block align-items-center rounded">CaptureMatches</a></li><li><a href="struct.CaptureNames.html" class="d-inline-block align-items-center rounded">CaptureNames</a></li><li><a href="struct.Captures.html" class="d-inline-block align-items-center rounded">Captures</a></li><li><a href="struct.Match.html" class="d-inline-block align-items-center rounded">Match</a></li><li><a href="struct.Matches.html" class="d-inline-block align-items-center rounded">Matches</a></li><li><a href="struct.NoExpand.html" class="d-inline-block align-items-center rounded">NoExpand</a></li><li><a href="struct.Regex.html" class="d-inline-block align-items-center rounded">Regex</a></li><li><a href="struct.RegexBuilder.html" class="d-inline-block align-items-center rounded">RegexBuilder</a></li><li><a href="struct.RegexSet.html" class="d-inline-block align-items-center rounded">RegexSet</a></li><li><a href="struct.RegexSetBuilder.html" class="d-inline-block align-items-center rounded">RegexSetBuilder</a></li><li><a href="struct.ReplacerRef.html" class="d-inline-block align-items-center rounded">ReplacerRef</a></li><li><a href="struct.SetMatches.html" class="d-inline-block align-items-center rounded">SetMatches</a></li><li><a href="struct.SetMatchesIntoIter.html" class="d-inline-block align-items-center rounded">SetMatchesIntoIter</a></li><li><a href="struct.SetMatchesIter.html" class="d-inline-block align-items-center rounded">SetMatchesIter</a></li><li><a href="struct.Split.html" class="d-inline-block align-items-center rounded">Split</a></li><li><a href="struct.SplitN.html" class="d-inline-block align-items-center rounded">SplitN</a></li><li><a href="struct.SubCaptureMatches.html" class="d-inline-block align-items-center rounded">SubCaptureMatches</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#enums" data-bs-toggle="collapse" data-bs-target="#toc-enums" aria-expanded="true" aria-current="true"><strong>Enums</strong></a><ul id="toc-enums" class="collapse show"><li><a href="enum.Error.html" class="d-inline-block align-items-center rounded">Error</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#functions" data-bs-toggle="collapse" data-bs-target="#toc-functions" aria-expanded="true" aria-current="true"><strong>Functions</strong></a><ul id="toc-functions" class="collapse show"><li><a href="fn.escape.html" class="d-inline-block align-items-center rounded">escape</a></li></ul></li><li><a class="rd-btn-toc d-inline-block align-items-center rounded bi bi-caret-right-fill" href="#traits" data-bs-toggle="collapse" data-bs-target="#toc-traits" aria-expanded="true" aria-current="true"><strong>Traits</strong></a><ul id="toc-traits" class="collapse show"><li><a href="trait.Replacer.html" class="d-inline-block align-items-center rounded">Replacer</a></li></ul></li></ul></nav></div><div class="rd-content"><section><h2 id="modules" class="rd-anchor">Modules<a aria-label="anchor" href="#modules"><i class="bi bi-hash"></i></a></h2><div class="item-table"><div><p><a href="bytes/index.html" class="mod">bytes</a> <span role="tooltip" class="rd-tooltip"><i class="bi bi-gear"></i><span class="rd-tooltip-data">feature = &quot;std&quot;</span></span></p></div><div><p>Match regular expressions on arbitrary bytes.</p>
</div></div></section><section><h2 id="structs" class="rd-anchor">Structs<a aria-label="anchor" href="#structs"><i class="bi bi-hash"></i></a></h2><div class="item-table"><div><p><a href="struct.CaptureLocations.html" class="struct">CaptureLocations</a></p></div><div><p>CaptureLocations is a low level representation of the raw offsets of each
submatch.</p>
</div><div><p><a href="struct.CaptureMatches.html" class="struct">CaptureMatches</a></p></div><div><p>An iterator that yields all non-overlapping capture groups matching a
particular regular expression.</p>
</div><div><p><a href="struct.CaptureNames.html" class="struct">CaptureNames</a></p></div><div><p>An iterator over the names of all possible captures.</p>
</div><div><p><a href="struct.Captures.html" class="struct">Captures</a></p></div><div><p>Captures represents a group of captured strings for a single match.</p>
</div><div><p><a href="struct.Match.html" class="struct">Match</a></p></div><div><p>Match represents a single match of a regex in a haystack.</p>
</div><div><p><a href="struct.Matches.html" class="struct">Matches</a></p></div><div><p>An iterator over all non-overlapping matches for a particular string.</p>
</div><div><p><a href="struct.NoExpand.html" class="struct">NoExpand</a></p></div><div><p><code>NoExpand</code> indicates literal string replacement.</p>
</div><div><p><a href="struct.Regex.html" class="struct">Regex</a></p></div><div><p>A compiled regular expression for matching Unicode strings.</p>
</div><div><p><a href="struct.RegexBuilder.html" class="struct">RegexBuilder</a></p></div><div><p>A configurable builder for a regular expression.</p>
</div><div><p><a href="struct.RegexSet.html" class="struct">RegexSet</a></p></div><div><p>Match multiple (possibly overlapping) regular expressions in a single scan.</p>
</div><div><p><a href="struct.RegexSetBuilder.html" class="struct">RegexSetBuilder</a></p></div><div><p>A configurable builder for a set of regular expressions.</p>
</div><div><p><a href="struct.ReplacerRef.html" class="struct">ReplacerRef</a></p></div><div><p>By-reference adaptor for a <code>Replacer</code></p>
</div><div><p><a href="struct.SetMatches.html" class="struct">SetMatches</a></p></div><div><p>A set of matches returned by a regex set.</p>
</div><div><p><a href="struct.SetMatchesIntoIter.html" class="struct">SetMatchesIntoIter</a></p></div><div><p>An owned iterator over the set of matches from a regex set.</p>
</div><div><p><a href="struct.SetMatchesIter.html" class="struct">SetMatchesIter</a></p></div><div><p>A borrowed iterator over the set of matches from a regex set.</p>
</div><div><p><a href="struct.Split.html" class="struct">Split</a></p></div><div><p>Yields all substrings delimited by a regular expression match.</p>
</div><div><p><a href="struct.SplitN.html" class="struct">SplitN</a></p></div><div><p>Yields at most <code>N</code> substrings delimited by a regular expression match.</p>
</div><div><p><a href="struct.SubCaptureMatches.html" class="struct">SubCaptureMatches</a></p></div><div><p>An iterator that yields all capturing matches in the order in which they
appear in the regex.</p>
</div></div></section><section><h2 id="enums" class="rd-anchor">Enums<a aria-label="anchor" href="#enums"><i class="bi bi-hash"></i></a></h2><div class="item-table"><div><p><a href="enum.Error.html" class="enum">Error</a></p></div><div><p>An error that occurred during parsing or compiling a regular expression.</p>
</div></div></section><section><h2 id="functions" class="rd-anchor">Functions<a aria-label="anchor" href="#functions"><i class="bi bi-hash"></i></a></h2><div class="item-table"><div><p><a href="fn.escape.html" class="fn">escape</a></p></div><div><p>Escapes all regular expression meta characters in <code>text</code>.</p>
</div></div></section><section><h2 id="traits" class="rd-anchor">Traits<a aria-label="anchor" href="#traits"><i class="bi bi-hash"></i></a></h2><div class="item-table"><div><p><a href="trait.Replacer.html" class="trait">Replacer</a></p></div><div><p>Replacer describes types that can be used to replace matches in a string.</p>
</div></div></section></div></div></div><footer class="container-xxl text-center">The rd developpers - (c) 2022</footer><script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.min.js" integrity="sha384-cn7l7gDp0eyniUwwAZgrzD06kc/tftFf19TOAs2zVinnD/C7E91j9yyk5//jjpt/" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap-dark-5@1.1.3/dist/js/darkmode.min.js" integrity="sha384-A4SLs39X/aUfwRclRaXvNeXNBTLZdnZdHhhteqbYFS2jZTRD79tKeFeBn7SGXNpi" crossorigin="anonymous"></script><script src="../regex/search-index.js"></script><script src="../search.js"></script></body></html>
